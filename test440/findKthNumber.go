package test440

// 给定整数 n 和 k，找到 1 到 n 中字典序第 k 小的数字。
// 注意：1 ≤ k ≤ n ≤ 109。

// 建立一个10叉树 ,带好排序 0-9
// 注意:  root第一个不包含 0  ,可以将 第一个 0 做root 使用
// 这棵树只要求建立 ,当查询到树时 只管插入和 查询即可 ,不需要其他操作
// 查询
// 第一次 直接从 1- 9 开始 查询
// 后续查询也是  1-9 (因为直接存 数本身 例如 10 - 19) ,for遍历比较大小  首选递归操作
// 插入操作
// 遍历树 ,有则跳过 ,无则插入
// 树是这么添加的
//										0
//	1 2 3 4 5 6 7 8 9
// 10 11 12 13
// 每个节点直接存入该树即可 ,不要插入单个字符 ,查询时直接对比数 ,

// TODO 还是没能彻底理解 ,需要深入学习和改进
func findKthNumber(n int, k int) int {
	// 返回结果初始值用1 后面* 操作 ,用0 是不行的
	res := 1
	// 一开始 k需要-1 为什么呢?
	// 一开始的数字只有 1-9 对不对?( 9 个数) ,可是后面是  10 -19  (10 个数) ,第一次去到一个0 ,后面就不需要了
	k -= 1
	for k > 0 {
		// step是每次k变化都会重新计算一次
		// res ,res=1 是为了 * 10 之后可以保持 10叉树的间距 ,这样往后遍历,计算 k 在哪个区间内
		step := skip(n, res, res+1)
		// 这个很好理解指针需要跳跃的数在当前层 就直解计算,不在的话就往后一层
		if step <= k {
			k -= step
			res += 1
		} else {
			// step大于该层节点数
			k -= 1
			res *= 10
		}
	}
	return res
}

// 跳跃举例
func skip(target, l, r int) int {
	step := 0
	// 这是层层遍历 ,是10叉 树 一层层往下数 ,同时 得到,你要遍历的
	for l <= target {
		// target + 1 是为了包括根节点在内的
		step += min(r, target+1) - l
		// 对l ,r同时增大一层
		l *= 10
		r *= 10
	}
	return step
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
